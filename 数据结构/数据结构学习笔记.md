# 数据结构

* [课程链接（王道考研）](https://www.bilibili.com/video/BV1b7411N798?p=1&spm_id_from=pageDriver)
 
## 第一章

### 1、绪论

* 什么是数据？
    * 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。
* 什么是数据元素、数据项？
    * 数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可以由若干**数据项**组成，数据项是构成数据元素的不可分割的最小单位。
* 数据结构，数据对象：
    * 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。
    * 数据对象是具有相同性质的书卷元素的集合，是数据的一个子集。
* 逻辑结构：
    * 数据的逻辑结构分为：集合、线性结构、树形结构、图状结构（网状结构）
* 数据的物理结构（存储结构）：
    * 数据的存储结构分为：
        1. 顺序存储
        2. 链式存储
        3. 索引存储
        4. 散列存储
    * 以线性结构为例：
        *  顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。
        *  链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素地址的指针来表示元素之间的逻辑关系。
        *  索引存储：在存储元素信息的同时，还建立附加的索引表。表中的每项称为索引项，索引项的一般形式是（关键字，地址）。
        *  散列存储：根据元素的关键字直接计算出该元素的存储地址，又称**哈希（hash）存储**。
    * 一般可以将链式存储、索引存储、散列存储称为非顺序存储。
* 绪论部分需要理解两点：
    * 若采用顺序存储，则各个数据元素唉物理上必须是连续的；若采用非顺序存储，则各个数据元素在物理上可以是离散的。
    * 数据的存储结构会影响存储空间分配的方便程度。
    * 数据的存储结构会影响对数据运算的速度。
* 数据的运算：
    * 施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。
* 数据结构的三要素：
    1. 逻辑结构
    2. 物理结构（存储结构）
    3. 数据的运算
* 数据类型、抽象数据类型：
    * 数据类型是一个值的集合和定义在此集合上的一组操作的总称。
        1. 原子类型：其值不可再分的数据类型。（例如：一些编程语言中的bool类型，int类型等等，bool类型值的范围：true，false；可进行的操作：与、或、非...）
        2. 结构类型：其值可以再分解为若干成分（分量）的数据类型。（例如：C语言中的结构体等等）
    * 抽象数据类型（Abstract Data Type，ADT）是抽象数据组织及与之相关的操作。
        * ADT用数学化的语言定义数据的逻辑结构、定义运算，与具体的实现无关。
* 在探讨一种数据结构时的一般步骤：
    1. 定义逻辑结构（数据之间的关系）
    2. 定义数据的运算（针对现实需求，应该对这种逻辑结构进行什么样的运算）
    3. 确定某种存储结构，实现数据结构，并实现一些对数据结构的基本运算。
    
### 2、算法

* 什么是算法？  
    * `程序 = 数据结构 + 算法`
        * 其中数据结构实现的是：如何把现实世界的问题信息化，将信息存进计算机。同时还要实现对数据结构的基本操作。
        * 算法实现的是：如何处理这些信息，以解决实际问题。
* 算法的特性：
    * 有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可以在有穷时间内完成。（注：算法必须是有穷的，而程序可以是无穷的）
    * 确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。
    * 可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
    * 输入：一个算法有零个或多个输入，这些输入取自某个特定的对象的集合。
    * 输出：一个算法有一个或多个输出，这些输出是输入有着某种特定关系的量。
* “好”算法的特质（设计算法时要尽量追求的目标）
    * 正确性：算法应能够正确地解决求解问题。
    * 可读性：算法应具有良好的可读性，以帮助人们理解。（注：算法可以用伪代码描述，甚至可以用文字描述，重要的是要“无歧义”地描述出解决问题的步骤）
    * 健壮性：输入非法数据时，算法能适当地做出反应或进行处理，为不会产生莫名其妙的输出结果。
    * 高效率与低存储量需求：
        * 高效率：执行速度快，时间复杂度低。

******
* 今天是2021年3月4日，返校后第一次认真自我学习的一晚。继续加油哦！！！
* [继续学习P5](https://www.bilibili.com/video/BV1b7411N798?p=5&spm_id_from=pageDriver)
******

* 时间复杂度和空间复杂度：
    * 如何评价算法时间开销？
    * 方法一：事后统计运行时间
        * 存在的问题：
            1. 和机器性能有关，如超级计算机与单片机；
            2. 和编程语言有关，越高级的语言执行的效率越低；
            3. 和编译程序产生的及其指令质量有关；
            4. 有些算法是不能在事后统计的，如：导弹控制算法
    * 算法时间复杂度：
        * **事前预估**算法**时间开销T(n)**与**问题规模**n的关系（T表示“time”）
    
        ```c
        // 逐步递增型
        #include<stdio.h>
        void LoveYou(int n){ //n为问题规模
            int i = 1;
            while (i<=n)
            {
                i++;
                printf("I love you %d\n",i);
            }
            printf("I love you More Than %d\n",n);
            
        }
        int main(){
            LoveYou(3000);
        }
        ```
        
    * 算法时间复杂度：
        * 加法规则：多项相加，只保留最高阶的项，且系数变为1
            * T(n) = T<sub>1</sub>(n) + T<sub>2</sub>(n) = O(f(n))+O(g(n)) = O(max(f(n),g(n)))
        * 乘法规则：多项相乘，都保留
            * T(n) = T<sub>1</sub>(n) x T<sub>2</sub>(n) = O(f(n)) x O(g(n)) = O(f(n) x g(n))
            * Eg:T<sub>3</sub>(n)<br> = n<sup>3</sup> + n<sup>2</sup>log<sub>2</sub>n <br> = O(n<sup>3</sup>) + O(n<sup>2</sup>log<sub>2</sub>n) <br> = O(n<sup>3</sup>)
    * 常见的时间复杂度：
        * O(1) < O(log<sub>2</sub>n) < O(n) < O(nlog<sub>2</sub>n) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>) < O(n!) < O(n<sup>n</sup>)
        * 口诀：**==常对幂指阶==**
    
    ```c
    #include<stdio.h>
    void loveYou(int n){
        int i  = 1;
        while (i<=n)
        {
            i = i * 2;
            printf("I love you %d\n",i);
        }
        printf("I love you more than %d\n",n);
    }
    void main(){
        loveYou(3000);
    }
    ```
    
    * 计算上述算法的时间复杂度T(n)：设最深层循环的语句频度（总共循环的次数）为x，则由循环条件可知，循环结束时刚好满足2<sup>x</sup> > n。
        * x = log<sub>2</sub>n + 1 <br>T(n) = O(x) = O(log<sub>2</sub>n)
        
    * 最坏时间复杂度：最坏情况下算法的时间复杂度
    * 平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望运行时间
    * 最好时间复杂度：最好情况下算法的时间复杂度
    * 空间复杂度：
        * 算法原地工作：算法所需内存空间为常量
        
        ```c
        void test(int n){
            int flag[n]; //声明一个长度为n的数组
            int i;
            ...
        }
        ```
        
        * 假设一份int变量占4B，则所需内存空间= 4 + 4n + 4 = 4n + 8
    * 算法的空间复杂度：
        * 示例代码：

            ```c
            void LoveYou(int n){
                int i = 1;
                while (i<=n)
                {
                    i++;
                    printf("I love you %d\n",i);
                }
                printf("I love you more than %d\n",n);
            }
            void main(){
                LoveYou(3000);
            }
            ```
        
        * 无论问题规模怎么变，算法运行所需的内存空间都是规定的常量，算法空间复杂度为`S(n)= O(1)`，注：S表示Space。
        * 算法原地工作：算法所需内存空间为常量。